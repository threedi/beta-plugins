# -*- coding: utf-8 -*-
"""
Created on Mon Dec 13 09:15:34 2021

@author: chris.kerklaan

"""

# imports
import os
import numpy as np
from threedi_raster_edits import Vector, RasterGroup, Raster, Progress, LineString

def split_sample(levees, dem, distance=5):
    # first cut into pieces of 5 meter and sample some dem values
    sampled = levees.copy(shell=True)
    sampled.add_field("height", float)
    for levee in Progress(levees, "Cutting and sampling"):
        # create single levees due to multilinestrings
        for single_levee in levee.geometry.to_single():
            # split the levee in sections of 5 meter
            levee_lines = LineString(single_levee).split(distance)
            for levee_line in levee_lines:
                height = np.nanmean(dem.read(levee_line))
                sampled.add(geometry=levee_line, height=height, items=levee.items)
    return sampled

class Merge:
    def __init__(self, levees, field=None, height_field='height'):
        
        if field:
            field_data = {}
            for value in list(set(levees.table[field])):
                field_data[value] = levees.filter(return_vector=True, **{field:value})
            self.field_data = field_data
        self.data = levees.copy()
    
    def run_fields(self, threshold=0.25):
        field_output = self.data.copy(shell=True)
        for field, data in self.field_data.items():
            print(field)
            output  = self.run(data, threshold)
            for feature in output:
                field_output.add(feature)
        return field_output
        
    def run(self, data, threshold=0.25):
        output = data.copy(shell=True)
        output.add_field("m_count", int)
        output.add_field("m_aheight", float)
        output.add_field("m_max", float)
        output.add_field("m_min", float)
        
        data = data.copy() 
        data.reset()
        levee = next(data)
        levee_geometry = levee.geometry
        levee_items = levee.items
        heights = [levee['height']]
        data.delete(levee)
        
        while len(data) != 0:
            data.reset()
            levee_geometry, added_levees = add_adjacent_levees(heights, 
                                                               levee_geometry, 
                                                               data, 
                                                               threshold)
            
            
            if len(added_levees) == 0:
                # add to ouput
                output.add(geometry=levee_geometry, 
                                items=levee_items,
                                m_count=len(heights),
                                m_height =np.nanmean(heights),
                                m_max= np.nanmax(heights),
                                m_min = np.nanmin(heights)
                                )
                
                levee = next(data) # retrieves a new feature even if some are deleted
                levee_items= levee.items
                levee_geometry = levee.geometry
                heights = [levee['height']]
                data.delete(levee)
                    
            else:
                # delete from data and to heights
                for levee_id in added_levees:
                    added_levee = data[levee_id]
                    heights.append(added_levee['height'])
                    data.delete(added_levee)
                    
        data.close()
        
        return output
    
    def maximum_levees(self, maximum_amount, 
                       amount_range=10, 
                       starting_threshold=0.1, 
                       factor=0.1,
                       fields=False):
        """ A maximum number of levees can be given at the cost of height threshold
            With this function the optimal height is generated by the 
            amount of levees
            
            params:
                maximum_amount: Amount of levees you want in the area
                amount_range: if within this range we are correct!
        """

        data = self.data
        threshold = starting_threshold
        increase_threshold = threshold
 
        in_range = False
        lower_amount = maximum_amount - amount_range
        upper_amount = maximum_amount + amount_range
        
        threshold_used = [threshold]
        factor_used = [factor]
        
        direction = [0]
        count = 0
        while not in_range:
            print(count)
            output = self.run(data.copy(), threshold)

            in_range = lower_amount <= len(output) <= upper_amount
            if not in_range:
                print(f"Levee count", len(output),f"not in between {lower_amount} and {upper_amount} with Threshold:", threshold, "factor", factor)
               
                count += 1
                
                if len(output) < lower_amount:
                    direction.append(-1)
                
                
                if len(output) > upper_amount:
                    direction.append(1)
                
                print(direction)
                # last one was to high # increase speed
                if direction[-1] == 1: # same direction
                    factor += 0.01 # increase in the same direction
                    
                # last one was to low # decrease speed and set threshold back
                if direction[-1] == -1:
                    # reset the threshold and factor
                    factor = factor_used[-2]
                    threshold = threshold_used[-2]
                    # decreese
                    factor -= 0.01
                
                threshold += factor
                
                threshold_used.append(threshold)
                factor_used.append(factor)
                
            
                
            if in_range:
                print("Levees in range with threshold:", threshold,  "Levees", len(output))
            


        return output
        
        

def add_adjacent_levees(heights, levee_geometry,  levee_vector, threshold=0.25):    
    output_geometry = levee_geometry.copy()
    added_levees = []
    for levee in levee_vector.spatial_filter(levee_geometry.buffer(0.0001)):
        next_levee_height = levee['height']
        minimum_difference = abs(next_levee_height - min(heights)) < threshold
        maximum_difference = abs(next_levee_height - max(heights)) < threshold
        if minimum_difference and maximum_difference:
            added_levees.append(levee.id)        
            output_geometry = output_geometry.union(levee.geometry)
            output_geometry = output_geometry.dissolve()
            
    return output_geometry, added_levees

if __name__ == "__main__":
    
    os.chdir(r"C:\Users\chris.kerklaan\Documents\Projecten\basis kaarten hhnk\processing")
    # define linestring paths
    dem_tiles_dir = r"\\utr-3fs-01.nens.local\WorkDir\J_vLieshout\HHNK_AHN_basiskaarten\AHN4_Interpolated\ahn4_interpolated"
    levee_path = "data/merged2.gpkg"
    tile_path =  "data/AHN_HHNK_grenzen.shp"
    levees = Vector(levee_path)
    tiles = Vector(tile_path)
    
    # get all dem files
    dem_tiles =  [Raster(dem_tiles_dir + f"/{i}")  for i in os.listdir(dem_tiles_dir) if i.endswith("tif")]
    dem = RasterGroup(dem_tiles)
    
    # clip levees on a certain tile
    tile_name = '19gz2'
    tile = tiles.filter(name=tile_name)[0]
    tile_levee = levees.spatial_filter(tile.geometry, quiet=False, return_vector=True)
    
    tile_levee.write(f"levees/levees_{tile_name}.shp")
    sampled = split_sample(tile_levee, dem, distance=10)
    sampled.write(f"levees/sample_{tile_name}.shp")

    threshold = 0.25
    merge = Merge(sampled, height_field='height', field='type')
    output = merge.run_fields()
    output.write("levees/merged.gpkg")
    
