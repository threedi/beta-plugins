# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThreeDiCustomStatsDialog
                                 A QGIS plugin
 This plugin calculates statistics of 3Di results. The user chooses the variable, aggregation method and
 spatiotemperal filtering.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-11-27
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Leendert van Wolfswinkel | Nelen en Schuurmans
        email                : leendert.vanwolfswinkel@nelen-schuurmans.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
import sys
from collections import namedtuple
from types import MethodType

from qgis.PyQt import QtWidgets
from qgis.PyQt import uic
from qgis.PyQt.QtCore import QPersistentModelIndex
from qgis.PyQt.QtCore import Qt
from qgis.core import QgsProject, QgsCoordinateReferenceSystem, QgsMarkerSymbol
from qgis.gui import QgsFileWidget

from .threedi_result_aggregation import *
from .presets import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'threedi_custom_stats_dialog_base.ui'))

dialog_ui_fn = os.path.join(os.path.dirname(__file__), 'test_dialog.ui')

DEFAULT_AGGREGATION = Aggregation(variable=AGGREGATION_VARIABLES.get_by_short_name('q'),
                                  sign=AggregationSign(short_name='net', long_name='Net'),
                                  method=AGGREGATION_METHODS.get_by_short_name('sum')
                                  )

#### Styling related declarations --------------------
STYLE_DIR = os.path.join(os.path.dirname(__file__), 'style')
StyleType = namedtuple('StyleType', 'function qml')


def style_on_single_column(layer, qml: str, column: str):
    layer.loadNamedStyle(qml)
    layer.renderer().setClassAttribute(column)
    layer.renderer().updateClasses(vlayer=layer,
                                   mode=layer.renderer().mode(),
                                   nclasses=len(layer.renderer().ranges()))
    layer.triggerRepaint()


def style_as_vector(layer, qml: str, x: str, y: str):
    layer.loadNamedStyle(qml)
    class_attribute_string = 'sqrt("{x}" * "{x}" + "{y}" * "{y}")'.format(x=x, y=y)
    layer.renderer().setClassAttribute(class_attribute_string)
    layer.renderer().updateClasses(vlayer=layer,
                                   mode=layer.renderer().mode(),
                                   nclasses=len(layer.renderer().ranges()))
    rotation_expression = 'degrees(azimuth( make_point( 0,0), make_point( "{x}",  "{y}" )))'.format(x=x, y=y)
    data_defined_angle = QgsMarkerSymbol().dataDefinedAngle().fromExpression(rotation_expression)
    layer.renderer().sourceSymbol().setDataDefinedAngle(data_defined_angle)
    layer.triggerRepaint()


def style_ts_reduction_analysis(layer, qml: str, col1: str, col2: str, col3: str):
    layer.loadNamedStyle(qml)
    filter_expression = '{col1} >10 or {col2} > 50 or {col3} > 80'.format(col1=col1, col2=col2, col3=col3)
    layer.renderer().rootRule().children()[0].setFilterExpression(filterExp=filter_expression)
    layer.triggerRepaint()


def update_column_widget(self, demanded_aggregations, aggregation_variable_types: list):
    self.clear()
    filtered_das = filter_demanded_aggregations(demanded_aggregations, aggregation_variable_types)
    for da in filtered_das:
        column_name = da.as_column_name()
        if column_name is not None:
            self.addItem(da.as_column_name())


# --------------------

class ThreeDiCustomStatsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(ThreeDiCustomStatsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface

        self.gr = ''
        self.demanded_aggregations = []
        self.flowline_styling_widgets = [
            self.comboBoxFlowlinesStyleCol1,
            self.comboBoxFlowlinesStyleCol2,
            self.comboBoxFlowlinesStyleCol3,
            self.pushButtonFlowlinesStyleConfig
        ]

        self.node_styling_widgets = [
            self.comboBoxNodesStyleCol1,
            self.comboBoxNodesStyleCol2,
            self.pushButtonNodesStyleConfig
        ]

        self.cell_styling_widgets = [
            self.comboBoxCellsStyleCol1,
            self.pushButtonCellsStyleConfig
        ]

        for preset in PRESETS:
            self.comboBoxPreset.addItem(preset.name)
            self.comboBoxPreset.setItemData(self.comboBoxPreset.count() - 1, preset)
        self.comboBoxPreset.currentIndexChanged.connect(self.preset_combobox_changed)

        for widget in self.flowline_styling_widgets:
            widget.setVisible(False)
        for widget in self.node_styling_widgets:
            widget.setVisible(False)
        for widget in self.cell_styling_widgets:
            widget.setVisible(False)

        self.pushButtonAddAggregation.clicked.connect(self.add_aggregation)
        self.pushButtonRemoveAggregation.clicked.connect(self.remove_aggregation)
        self.add_aggregation()
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)

        self.QgsFileWidget3DiResults.fileChanged.connect(self.results_3di_selected)
        self.pushButtonMapCanvas.clicked.connect(self.set_extent_from_map_canvas)
        self.set_extent_from_map_canvas()
        self.mExtentGroupBox.setChecked(False)

        self.checkBoxGenerateRasters.stateChanged.connect(self.enable_raster_folder_widget)
        self.mQgsFileWidgetRasterFolder.setStorageMode(QgsFileWidget.GetDirectory)
        self.mQgsFileWidgetRasterFolder.fileChanged.connect(self.validate)

        self.init_styling_tab()
        self.set_styling_tab()

        self.dialogButtonBoxOKCancel.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)

    def add_aggregation(self, *args, aggregation: Aggregation = DEFAULT_AGGREGATION):
        """Add a new row to tableWidgetAggregations, always last row"""
        self.tableWidgetAggregations.insertRow(self.tableWidgetAggregations.rowCount())
        current_row = self.tableWidgetAggregations.rowCount() - 1

        # variable column
        variable_combobox = QtWidgets.QComboBox()
        for i, variable in enumerate(AGGREGATION_VARIABLES):
            variable_combobox.addItem(VT_NAMES[variable.var_type] + ': ' + variable.long_name)
            variable_combobox.setItemData(i, variable)
        idx = variable_combobox.findText(aggregation.variable.long_name, Qt.MatchEndsWith)
        variable_combobox.setCurrentIndex(idx)
        variable_combobox.currentTextChanged.connect(self.variable_combobox_text_changed)
        self.tableWidgetAggregations.setCellWidget(current_row, 0, variable_combobox)

        # sign column
        direction_combobox = QtWidgets.QComboBox()
        counter = 0
        for s in AGGREGATION_SIGNS:
            direction_combobox.addItem(s.long_name)
            direction_combobox.setItemData(counter, s)
            counter += 1
        direction_combobox.setCurrentText(aggregation.sign.long_name)
        self.tableWidgetAggregations.setCellWidget(current_row, 1, direction_combobox)
        direction_combobox.currentTextChanged.connect(self.direction_combobox_text_changed)

        # method column
        method_combobox = QtWidgets.QComboBox()
        for i, method in enumerate(AGGREGATION_METHODS):
            method_combobox.addItem(method.long_name)
            method_combobox.setItemData(i, method)
        method_combobox.setCurrentText(aggregation.method.long_name)
        self.tableWidgetAggregations.setCellWidget(current_row, 2, method_combobox)
        method_combobox.currentTextChanged.connect(self.method_combobox_text_changed)

        # threshold column
        threshold_widget = QtWidgets.QDoubleSpinBox()
        threshold_widget.setRange(sys.float_info.min, sys.float_info.max)
        self.tableWidgetAggregations.setCellWidget(current_row, 3, threshold_widget)
        method = method_combobox.itemData(method_combobox.currentIndex())
        self.set_threshold_widget(row=current_row, method=method)
        if aggregation.threshold is not None:
            threshold_widget.setValue(aggregation.threshold)
        threshold_widget.valueChanged.connect(self.threshold_value_changed)

        # units column
        units_combobox = QtWidgets.QComboBox()
        self.tableWidgetAggregations.setCellWidget(current_row, 4, units_combobox)
        self.set_units_widget(row=current_row,
                              variable=variable_combobox.itemData(variable_combobox.currentIndex()),
                              method=method
                              )
        # TODO: dit nu nu lastig te setten obv aggregation, omdat die wel een attribuut multiplier heeft,
        #  maar niet een attribuut units. laat ik nu even voor wat het is
        units_combobox.currentTextChanged.connect(self.units_combobox_text_changed)
        self.update_demanded_aggregations()
        self.set_styling_tab()
        self.validate()

    def remove_aggregation(self):
        index_list = []
        for model_index in self.tableWidgetAggregations.selectionModel().selectedRows():
            index = QPersistentModelIndex(model_index)
            index_list.append(index)

        for index in index_list:
            self.tableWidgetAggregations.removeRow(index.row())
        self.validate()

    def variable_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        self.set_method_widget(row, variable)
        self.set_direction_widget(row, variable)
        self.update_demanded_aggregations()

    def method_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
        method = method_widget.itemData(method_widget.currentIndex())
        if method is not None:  # this happens when the method widget is cleared before refilling it
            self.set_threshold_widget(row=row, method=method)
            self.set_units_widget(row=row, variable=variable, method=method)
            self.update_demanded_aggregations()

    def direction_combobox_text_changed(self):
        self.update_demanded_aggregations()

    def threshold_value_changed(self):
        self.update_demanded_aggregations()

    def units_combobox_text_changed(self):
        self.update_demanded_aggregations()

    def set_direction_widget(self, row, variable):
        na_index = self.tableWidgetAggregations.cellWidget(row, 1).findText(NA_TEXT)
        if variable.signed:
            if na_index != -1:
                self.tableWidgetAggregations.cellWidget(row, 1).removeItem(na_index)
            self.tableWidgetAggregations.cellWidget(row, 1).setCurrentIndex(0)
        else:
            if na_index == -1:
                self.tableWidgetAggregations.cellWidget(row, 1).addItem(NA_TEXT)
                na_index = self.tableWidgetAggregations.cellWidget(row, 1).findText(NA_TEXT)
            self.tableWidgetAggregations.cellWidget(row, 1).setCurrentIndex(na_index)
        self.tableWidgetAggregations.cellWidget(row, 1).setEnabled(variable.signed)

    def set_method_widget(self, row, variable):
        self.tableWidgetAggregations.cellWidget(row, 2).clear()
        for i, method_short_name in enumerate(variable.applicable_methods):
            method = AGGREGATION_METHODS.get_by_short_name(method_short_name)
            self.tableWidgetAggregations.cellWidget(row, 2).addItem(method.long_name)
            self.tableWidgetAggregations.cellWidget(row, 2).setItemData(i, method)
        method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
        method = method_widget.itemData(method_widget.currentIndex())
        self.set_threshold_widget(row=row, method=method)

    def set_threshold_widget(self, row, method):
        self.tableWidgetAggregations.cellWidget(row, 3).setEnabled(method.has_threshold)

    def set_units_widget(self, row, variable, method):
        """Called when variable or method changes"""
        units_widget = self.tableWidgetAggregations.cellWidget(row, 4)
        units_widget.clear()
        units_dict = variable.units
        for i, units in enumerate(units_dict.keys()):
            multiplier_tuple = units_dict[units]
            multiplier = multiplier_tuple[0]
            if method.integrates_over_time:
                units_str = units[0]
            else:
                units_str = '/'.join(units)
                if len(multiplier_tuple) == 2:
                    multiplier *= multiplier_tuple[1]
            if method.is_percentage:
                units_str = '%'
                multiplier = 1
            # add item to the widget if no similar item exists:
            if not any(units_str in units_widget.itemText(i) for i in range(units_widget.count())):
                units_widget.addItem(units_str)
                units_widget.setItemData(i, multiplier)

    def get_flowlines_style_col1_value(self):
        return {'column': self.comboBoxFlowlinesStyleCol1.currentText()}

    def get_flowlines_style_3_column_values(self):
        return {'col1': self.comboBoxFlowlinesStyleCol1.currentText(),
                'col2': self.comboBoxFlowlinesStyleCol2.currentText(),
                'col3': self.comboBoxFlowlinesStyleCol3.currentText()
                }

    def get_nodes_style_col1_value(self):
        return {'column': self.comboBoxNodesStyleCol1.currentText()}

    def get_nodes_style_vector_values(self):
        return {'x': self.comboBoxNodesStyleCol1.currentText(),
                'y': self.comboBoxNodesStyleCol2.currentText()
                }

    def get_cells_style_col1_value(self):
        return {'column': self.comboBoxCellsStyleCol1.currentText()}

    def init_styling_tab(self):
        # Flowlines style type combobox
        item_data = {'function': style_on_single_column,
                     'kwargs_getter': self.get_flowlines_style_col1_value,
                     'qml': os.path.join(STYLE_DIR, 'flowline.qml'),
                     'widgets': [self.comboBoxFlowlinesStyleCol1]
                     }
        self.comboBoxFlowlinesStyleType.addItem('Single column graduated')
        self.comboBoxFlowlinesStyleType.setItemData(0, item_data)

        # TODO: Add styling for timestep reduction analysis
        item_data = {'function': style_ts_reduction_analysis,
                     'kwargs_getter': self.get_flowlines_style_3_column_values,
                     'qml': os.path.join(STYLE_DIR, 'ts_reduction_analysis.qml'),
                     'widgets': [self.comboBoxFlowlinesStyleCol1,
                                 self.comboBoxFlowlinesStyleCol2,
                                 self.comboBoxFlowlinesStyleCol3]
                     }
        self.comboBoxFlowlinesStyleType.addItem('Timestep reduction analysis')
        self.comboBoxFlowlinesStyleType.setItemData(1, item_data)

        self.comboBoxFlowlinesStyleType.currentIndexChanged.connect(self.flowline_styling_type_changed)

        # Nodes style type combobox
        item_data = {'function': style_on_single_column,
                     'kwargs_getter': self.get_nodes_style_col1_value,
                     'qml': os.path.join(STYLE_DIR, 'node.qml'),
                     'widgets': [self.comboBoxNodesStyleCol1]
                     }
        self.comboBoxNodesStyleType.addItem('Single column graduated')
        self.comboBoxNodesStyleType.setItemData(0, item_data)
        item_data = {'function': style_as_vector,
                     'kwargs_getter': self.get_nodes_style_vector_values,
                     'qml': os.path.join(STYLE_DIR, 'vector.qml'),
                     'widgets': [self.comboBoxNodesStyleCol1,
                                 self.comboBoxNodesStyleCol2,
                                 ]
                     }
        self.comboBoxNodesStyleType.addItem('Vector')
        self.comboBoxNodesStyleType.setItemData(1, item_data)
        self.comboBoxNodesStyleType.currentIndexChanged.connect(self.node_styling_type_changed)

        # Cells style type combobox
        item_data = {'function': style_on_single_column,
                     'kwargs_getter': self.get_cells_style_col1_value,
                     'qml': os.path.join(STYLE_DIR, 'cell.qml'),
                     'widgets': [self.comboBoxCellsStyleCol1]
                     }
        self.comboBoxCellsStyleType.addItem('Single column graduated')
        self.comboBoxCellsStyleType.setItemData(0, item_data)
        self.comboBoxCellsStyleType.currentIndexChanged.connect(self.cell_styling_type_changed)

        # add update method to style config widgets
        self.comboBoxFlowlinesStyleCol1.update = MethodType(update_column_widget, self.comboBoxFlowlinesStyleCol1)
        self.comboBoxFlowlinesStyleCol2.update = MethodType(update_column_widget, self.comboBoxFlowlinesStyleCol2)
        self.comboBoxFlowlinesStyleCol3.update = MethodType(update_column_widget, self.comboBoxFlowlinesStyleCol3)
        self.pushButtonFlowlinesStyleConfig.update = MethodType(update_column_widget,
                                                                self.pushButtonFlowlinesStyleConfig)
        self.comboBoxNodesStyleCol1.update = MethodType(update_column_widget, self.comboBoxNodesStyleCol1)
        self.comboBoxNodesStyleCol2.update = MethodType(update_column_widget, self.comboBoxNodesStyleCol2)
        self.pushButtonNodesStyleConfig.update = MethodType(update_column_widget, self.pushButtonNodesStyleConfig)
        self.comboBoxCellsStyleCol1.update = MethodType(update_column_widget, self.comboBoxCellsStyleCol1)
        self.pushButtonCellsStyleConfig.update = MethodType(update_column_widget, self.pushButtonCellsStyleConfig)

    def set_styling_tab(self,
                        flowline_styling_type: str = 'Single column graduated',
                        nodes_styling_type: str = 'Single column graduated',
                        cells_styling_type: str = 'Single column graduated'
                        ):
        # Flowlines
        for widget in self.flowline_styling_widgets:
            widget.setVisible(False)
        filtered_das = filter_demanded_aggregations(self.demanded_aggregations, [VT_FLOW, VT_FLOW_HYBRID])
        if len(filtered_das) > 0:
            idx = self.comboBoxFlowlinesStyleType.findText(flowline_styling_type)
            if idx > -1:
                self.comboBoxFlowlinesStyleType.setCurrentIndex(idx)
            self.comboBoxFlowlinesStyleType.setEnabled(True)
            self.flowline_styling_type_changed()
        else:
            self.comboBoxFlowlinesStyleType.setEnabled(False)

        # Nodes and cells
        for widget in self.node_styling_widgets:
            widget.setVisible(False)
        for widget in self.cell_styling_widgets:
            widget.setVisible(False)
        filtered_das = filter_demanded_aggregations(self.demanded_aggregations, [VT_NODE, VT_NODE_HYBRID])
        if len(filtered_das) > 0:
            idx = self.comboBoxNodesStyleType.findText(nodes_styling_type)
            if idx > -1:
                self.comboBoxNodesStyleType.setCurrentIndex(idx)
            self.comboBoxNodesStyleType.setEnabled(True)
            self.node_styling_type_changed()
            idx = self.comboBoxCellsStyleType.findText(cells_styling_type)
            if idx > -1:
                self.comboBoxCellsStyleType.setCurrentIndex(idx)
            self.comboBoxCellsStyleType.setEnabled(True)
            self.cell_styling_type_changed()
        else:
            self.comboBoxNodesStyleType.setEnabled(False)
            self.comboBoxCellsStyleType.setEnabled(False)

    def flowline_styling_type_changed(self):
        # set flowline styling config widgets to invisible
        for widget in self.flowline_styling_widgets:
            widget.setVisible(False)

        # make new widgets visible and try to set combobox current text based on demanded aggregations
        type_widget = self.comboBoxFlowlinesStyleType
        item_data = type_widget.itemData(type_widget.currentIndex())
        if item_data is not None:
            relevant_widgets = type_widget.itemData(type_widget.currentIndex())['widgets']
            for i, widget in enumerate(relevant_widgets):
                widget.update(demanded_aggregations=self.demanded_aggregations,
                              aggregation_variable_types=[VT_FLOW, VT_FLOW_HYBRID])
                widget.setCurrentIndex(i)
                widget.setVisible(True)
                widget.setEnabled(True)

    def node_styling_type_changed(self):
        # set node styling config widgets to invisible
        for widget in self.node_styling_widgets:
            widget.setVisible(False)

        # make new widgets visible
        type_widget = self.comboBoxNodesStyleType
        item_data = type_widget.itemData(type_widget.currentIndex())
        if item_data is not None:
            relevant_widgets = type_widget.itemData(type_widget.currentIndex())['widgets']
            for i, widget in enumerate(relevant_widgets):
                widget.update(demanded_aggregations=self.demanded_aggregations,
                              aggregation_variable_types=[VT_NODE, VT_NODE_HYBRID])
                widget.setCurrentIndex(i)
                widget.setVisible(True)
                widget.setEnabled(True)

    def cell_styling_type_changed(self):
        # set cell styling config widgets to invisible
        for widget in self.cell_styling_widgets:
            widget.setVisible(False)

        # make new widgets visible
        type_widget = self.comboBoxCellsStyleType
        item_data = type_widget.itemData(type_widget.currentIndex())
        if item_data is not None:
            relevant_widgets = type_widget.itemData(type_widget.currentIndex())['widgets']
            for i, widget in enumerate(relevant_widgets):
                widget.update(demanded_aggregations=self.demanded_aggregations,
                              aggregation_variable_types=[VT_NODE, VT_NODE_HYBRID])
                widget.setCurrentIndex(i)
                widget.setVisible(True)
                widget.setEnabled(True)

    def update_gr(self):
        results_3di = self.QgsFileWidget3DiResults.filePath()
        gridadmin = self.QgsFileWidgetGridAdmin.filePath()
        if os.path.isfile(results_3di) and os.path.isfile(gridadmin):
            self.gr = GridH5ResultAdmin(gridadmin, results_3di)
            crs = QgsCoordinateReferenceSystem("EPSG:{}".format(self.gr.epsg_code))
            self.mExtentGroupBox.setOutputCrs(crs)
        else:
            self.gr = None

    def results_3di_selected(self):
        # set path to gridadmin.h5
        results_3di = self.QgsFileWidget3DiResults.filePath()
        if os.path.isfile(results_3di):
            results_3di_dir = os.path.dirname(results_3di)
            gridadmin = os.path.join(results_3di_dir, 'gridadmin.h5')
            if os.path.isfile(gridadmin):
                self.QgsFileWidgetGridAdmin.setFilePath(gridadmin)
                self.update_gr()
                output_timestep_best_guess = int(self.gr.nodes.timestamps[-1] / (len(self.gr.nodes.timestamps) - 1))
                self.doubleSpinBoxStartTime.setMaximum(int(self.gr.nodes.timestamps[-1]))
                self.doubleSpinBoxStartTime.setSingleStep(output_timestep_best_guess)
                self.doubleSpinBoxEndTime.setSingleStep(output_timestep_best_guess)
                self.doubleSpinBoxEndTime.setMaximum(int(self.gr.nodes.timestamps[-1]))
                self.doubleSpinBoxEndTime.setValue(int(self.gr.nodes.timestamps[-1]))
                if self.mQgsFileWidgetRasterFolder.filePath() == '':
                    self.mQgsFileWidgetRasterFolder.setFilePath(results_3di_dir)
                # Onderstaande is tijdelijk nodig vanwege een bug in threedigrid of qgis of de combinatie
                if hasattr(self.gr.lines, 'line_geometries'):
                    self.lineGeometryWarningLabel.setText('')
                else:
                    self.lineGeometryWarningLabel.setText("Warning: no line geometries found. Flowline length instead "
                                                          "of geometry length will be used to calculate max timestep "
                                                          "for culverts and channels.")
        self.validate()

    def set_extent_from_map_canvas(self):
        canvas_extent = self.iface.mapCanvas().extent()
        project = QgsProject.instance()
        crs = project.crs()
        self.mExtentGroupBox.setOutputExtentFromUser(canvas_extent, crs)
        # self.mExtentGroupBox.setCurrentExtent()

    def enable_raster_folder_widget(self):
        if self.checkBoxGenerateRasters.isChecked():
            self.mQgsFileWidgetRasterFolder.setEnabled(True)
        else:
            self.mQgsFileWidgetRasterFolder.setEnabled(False)
        self.validate()

    def preset_combobox_changed(self, index):
        preset = self.comboBoxPreset.itemData(index)
        self.presetHelpTextBrowser.setText(preset.description)
        self.apply_preset(preset)

    def apply_preset(self, preset: Preset):
        # remove existing aggregations
        self.tableWidgetAggregations.setRowCount(0)

        # add aggregations from preset
        for da in preset.aggregations():
            self.add_aggregation(aggregation=da)

        # set "resample point layer" from preset
        self.checkBoxResample.setChecked(preset.resample_point_layer)

        # set styling from preset
        self.set_styling_tab(flowline_styling_type=preset.flowlines_styling_type,
                             nodes_styling_type=preset.nodes_styling_type,
                             cells_styling_type=preset.cells_styling_type)

    def update_demanded_aggregations(self):
        self.demanded_aggregations = []
        for row in range(self.tableWidgetAggregations.rowCount()):
            # Variable
            variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
            variable = variable_widget.itemData(variable_widget.currentIndex())

            # Direction
            direction_widget = self.tableWidgetAggregations.cellWidget(row, 1)
            sign = direction_widget.itemData(direction_widget.currentIndex())

            # Method
            method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
            method = method_widget.itemData(method_widget.currentIndex())

            # Threshold
            threshold = self.tableWidgetAggregations.cellWidget(row, 3).value()

            # Multiplier (unit conversion)
            units_widget = self.tableWidgetAggregations.cellWidget(row, 4)
            multiplier = units_widget.itemData(units_widget.currentIndex())

            da = Aggregation(variable=variable,
                             sign=sign,
                             method=method,
                             threshold=threshold,
                             multiplier=multiplier)

            self.demanded_aggregations.append(da)

        self.set_styling_tab()

    def validate(self):
        valid = True
        if not isinstance(self.gr, GridH5ResultAdmin):
            valid = False
        if not self.tableWidgetAggregations.rowCount() > 0:
            valid = False
        if self.checkBoxGenerateRasters.isChecked() and self.mQgsFileWidgetRasterFolder.filePath() == '':
            valid = False
        self.dialogButtonBoxOKCancel.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(valid)


class StylingConfigDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super(StylingConfigDialog, self).__init__(parent)
        uic.loadUi(dialog_ui_fn, self)
        self.show()
