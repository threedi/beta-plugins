# -*- coding: utf-8 -*-
"""
/***************************************************************************
 ThreeDiCustomStatsDialog
                                 A QGIS plugin
 This plugin calculates statistics of 3Di results. The user chooses the variable, aggregation method and
 spatiotemperal filtering.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2019-11-27
        git sha              : $Format:%H$
        copyright            : (C) 2019 by Leendert van Wolfswinkel | Nelen en Schuurmans
        email                : leendert.vanwolfswinkel@nelen-schuurmans.nl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os, sys

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QPersistentModelIndex
from qgis.core import Qgis, QgsProject, QgsCoordinateReferenceSystem
from qgis.gui import QgsFileWidget

from .ThreeDiResultAggregation import *

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'threedi_custom_stats_dialog_base.ui'))

dialog_ui_fn = os.path.join(os.path.dirname(__file__), 'test_dialog.ui')


class ThreeDiCustomStatsDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(ThreeDiCustomStatsDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)
        self.iface = iface

        self.gr = ''

        self.pushButtonAddAggregation.clicked.connect(self.add_aggregation)
        self.pushButtonRemoveAggregation.clicked.connect(self.remove_aggregation)
        self.add_aggregation()
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(0, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(1, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(2, QtWidgets.QHeaderView.Stretch)
        self.tableWidgetAggregations.horizontalHeader().setSectionResizeMode(3, QtWidgets.QHeaderView.Stretch)

        self.QgsFileWidget3DiResults.fileChanged.connect(self.results_3di_selected)
        self.pushButtonMapCanvas.clicked.connect(self.set_extent_from_map_canvas)
        self.set_extent_from_map_canvas()
        self.mExtentGroupBox.setChecked(False)

        self.checkBoxGenerateRasters.stateChanged.connect(self.enable_raster_folder_widget)
        self.mQgsFileWidgetRasterFolder.setStorageMode(QgsFileWidget.GetDirectory)
        self.mQgsFileWidgetRasterFolder.fileChanged.connect(self.validate)
        self.dialogButtonBoxOKCancel.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(False)

        self.demanded_aggregations = []

        self.pushButtonUpdate.clicked.connect(self.update_demanded_aggregations)

    def add_aggregation(self):
        """Add a new row to tableWidgetAggregations, always last row"""
        self.tableWidgetAggregations.insertRow(self.tableWidgetAggregations.rowCount())
        current_row = self.tableWidgetAggregations.rowCount() - 1

        # variable column
        variable_combobox = QtWidgets.QComboBox()
        for i, variable in enumerate(AGGREGATION_VARIABLES):
            variable_combobox.addItem(VT_NAMES[variable.var_type] + ': ' + variable.long_name)
            variable_combobox.setItemData(i, variable)
        variable_combobox.currentTextChanged.connect(self.variable_combobox_text_changed)
        self.tableWidgetAggregations.setCellWidget(current_row, 0, variable_combobox)

        # direction column
        direction_combobox = QtWidgets.QComboBox()
        counter = 0
        for direction, sign in DIRECTION_SIGNS.items():
            direction_combobox.addItem(direction)
            direction_combobox.setItemData(counter, sign)
            counter += 1
        self.tableWidgetAggregations.setCellWidget(current_row, 1, direction_combobox)
        direction_combobox.currentTextChanged.connect(self.direction_combobox_text_changed)

        # method column
        method_combobox = QtWidgets.QComboBox()
        for i, method in enumerate(AGGREGATION_METHODS):
            method_combobox.addItem(method.long_name)
            method_combobox.setItemData(i, method)
        self.tableWidgetAggregations.setCellWidget(current_row, 2, method_combobox)
        method_combobox.currentTextChanged.connect(self.method_combobox_text_changed)

        # threshold column
        threshold_widget = QtWidgets.QDoubleSpinBox()
        threshold_widget.setRange(sys.float_info.min, sys.float_info.max)
        self.tableWidgetAggregations.setCellWidget(current_row, 3, threshold_widget)
        method = method_combobox.itemData(method_combobox.currentIndex())
        self.set_threshold_widget(row=current_row, method=method)
        threshold_widget.valueChanged.connect(self.threshold_value_changed)

        # units column
        units_combobox = QtWidgets.QComboBox()
        self.tableWidgetAggregations.setCellWidget(current_row, 4, units_combobox)
        self.set_units_widget(row=current_row,
                              variable=variable_combobox.itemData(variable_combobox.currentIndex()),
                              method=method
                              )
        units_combobox.currentTextChanged.connect(self.units_combobox_text_changed)

        self.validate()

    def remove_aggregation(self):
        index_list = []
        for model_index in self.tableWidgetAggregations.selectionModel().selectedRows():
            index = QPersistentModelIndex(model_index)
            index_list.append(index)

        for index in index_list:
            self.tableWidgetAggregations.removeRow(index.row())
        self.validate()

    def variable_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        self.set_method_widget(row, variable)
        self.set_direction_widget(row, variable)
        self.update_demanded_aggregations()

    def method_combobox_text_changed(self):
        row = self.tableWidgetAggregations.currentRow()
        variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
        variable = variable_widget.itemData(variable_widget.currentIndex())
        method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
        method = method_widget.itemData(method_widget.currentIndex())
        if method is not None: # this happens when the method widget is cleared before refilling it
            self.set_threshold_widget(row=row, method=method)
            self.set_units_widget(row=row, variable=variable, method=method)
        self.update_demanded_aggregations()

    def direction_combobox_text_changed(self):
        self.update_demanded_aggregations()

    def threshold_value_changed(self):
        self.update_demanded_aggregations()

    def units_combobox_text_changed(self):
        self.update_demanded_aggregations()

    def set_direction_widget(self, row, variable):
        na_index = self.tableWidgetAggregations.cellWidget(row, 1).findText(NA_TEXT)
        if variable.signed:
            if na_index != -1:
                self.tableWidgetAggregations.cellWidget(row, 1).removeItem(na_index)
            self.tableWidgetAggregations.cellWidget(row, 1).setCurrentIndex(0)
        else:
            if na_index == -1:
                self.tableWidgetAggregations.cellWidget(row, 1).addItem(NA_TEXT)
                na_index = self.tableWidgetAggregations.cellWidget(row, 1).findText(NA_TEXT)
            self.tableWidgetAggregations.cellWidget(row, 1).setCurrentIndex(na_index)
        self.tableWidgetAggregations.cellWidget(row, 1).setEnabled(variable.signed)

    def set_method_widget(self, row, variable):
        self.tableWidgetAggregations.cellWidget(row, 2).clear()
        for i, method_short_name in enumerate(variable.applicable_methods):
            method = AGGREGATION_METHODS.get_by_short_name(method_short_name)
            self.tableWidgetAggregations.cellWidget(row, 2).addItem(method.long_name)
            self.tableWidgetAggregations.cellWidget(row, 2).setItemData(i, method)
        method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
        method = method_widget.itemData(method_widget.currentIndex())
        self.set_threshold_widget(row=row, method=method)

    def set_threshold_widget(self, row, method):
        self.tableWidgetAggregations.cellWidget(row, 3).setEnabled(method.has_threshold)

    def set_units_widget(self, row, variable, method):
        """Called when variable or method changes"""
        units_widget = self.tableWidgetAggregations.cellWidget(row, 4)
        units_widget.clear()
        units_dict = variable.units
        for i, units in enumerate(units_dict.keys()):
            multiplier_tuple = units_dict[units]
            multiplier = multiplier_tuple[0]
            if method.integrates_over_time:
                units_str = units[0]
            else:
                units_str = '/'.join(units)
                if len(multiplier_tuple) == 2:
                    multiplier *= multiplier_tuple[1]
            if method.is_percentage:
                units_str = '%'
                multiplier = 1
            # add item to the widget if no similar item exists:
            if not any(units_str in units_widget.itemText(i) for i in range(units_widget.count())):
                units_widget.addItem(units_str)
                units_widget.setItemData(i, multiplier)

    def update_gr(self):
        results_3di = self.QgsFileWidget3DiResults.filePath()
        gridadmin = self.QgsFileWidgetGridAdmin.filePath()
        if os.path.isfile(results_3di) and os.path.isfile(gridadmin):
            self.gr = GridH5ResultAdmin(gridadmin, results_3di)
            crs = QgsCoordinateReferenceSystem("EPSG:{}".format(self.gr.epsg_code))
            self.mExtentGroupBox.setOutputCrs(crs)
        else:
            self.gr = None

    def results_3di_selected(self):
        # set path to gridadmin.h5
        results_3di = self.QgsFileWidget3DiResults.filePath()
        if os.path.isfile(results_3di):
            results_3di_dir = os.path.dirname(results_3di)
            gridadmin = os.path.join(results_3di_dir, 'gridadmin.h5')
            if os.path.isfile(gridadmin):
                self.QgsFileWidgetGridAdmin.setFilePath(gridadmin)
                self.update_gr()
                output_timestep_best_guess=int(self.gr.nodes.timestamps[-1]/(len(self.gr.nodes.timestamps)-1))
                self.doubleSpinBoxStartTime.setMaximum(int(self.gr.nodes.timestamps[-1]))
                self.doubleSpinBoxStartTime.setSingleStep(output_timestep_best_guess)
                self.doubleSpinBoxEndTime.setSingleStep(output_timestep_best_guess)
                self.doubleSpinBoxEndTime.setMaximum(int(self.gr.nodes.timestamps[-1]))
                self.doubleSpinBoxEndTime.setValue(int(self.gr.nodes.timestamps[-1]))
                if self.mQgsFileWidgetRasterFolder.filePath() == '':
                    self.mQgsFileWidgetRasterFolder.setFilePath(results_3di_dir)
                # Onderstaande is tijdelijk nodig vanwege een bug in threedigrid of qgis of de combinatie
                if hasattr(self.gr.lines, 'line_geometries'):
                    self.lineGeometryWarningLabel.setText('')
                else:
                    self.lineGeometryWarningLabel.setText("Warning: no line geometries found. Flowline length instead "
                                                          "of geometry length will be used to calculate max timestep "
                                                          "for culverts and channels.")
        self.validate()

    def set_extent_from_map_canvas(self):
        canvas_extent = self.iface.mapCanvas().extent()
        project = QgsProject.instance()
        crs=project.crs()
        self.mExtentGroupBox.setOutputExtentFromUser(canvas_extent, crs)
        # self.mExtentGroupBox.setCurrentExtent()

    def enable_raster_folder_widget(self):
        if self.checkBoxGenerateRasters.isChecked():
            self.mQgsFileWidgetRasterFolder.setEnabled(True)
        else:
            self.mQgsFileWidgetRasterFolder.setEnabled(False)
        self.validate()

    def update_demanded_aggregations(self):
        self.demanded_aggregations = []
        for row in range(self.tableWidgetAggregations.rowCount()):
            row_dict = {}
            # Variable
            variable_widget = self.tableWidgetAggregations.cellWidget(row, 0)
            variable = variable_widget.itemData(variable_widget.currentIndex())
            row_dict['variable'] = variable.short_name

            # Direction
            direction_widget = self.tableWidgetAggregations.cellWidget(row, 1)
            row_dict['sign'] = direction_widget.itemData(direction_widget.currentIndex())

            # Method
            method_widget = self.tableWidgetAggregations.cellWidget(row, 2)
            method = method_widget.itemData(method_widget.currentIndex())
            # TODO: dit op een betere manier voorkomen
            if method is not None:
                row_dict['method'] = method.short_name

            # Threshold
            row_dict['threshold'] = self.tableWidgetAggregations.cellWidget(row, 3).value()
            self.demanded_aggregations.append(row_dict)

            # Multiplier (unit conversion)
            units_widget = self.tableWidgetAggregations.cellWidget(row, 4)
            row_dict['multiplier'] = units_widget.itemData(units_widget.currentIndex())
            self.demanded_aggregations.append(row_dict)

        # self.set_styling_tab()

    # def set_styling_tab(self):
    #
    #     # a = StylingConfigDialog(parent=self)
    #     self.comboBoxFlowlinesStyleType.setEnabled(False)
    #     self.comboBoxFlowlinesStyleCol1.setEnabled(False)
    #     self.comboBoxNodesStyleType.setEnabled(False)
    #     self.comboBoxNodesStyleCol1.setEnabled(False)
    #     self.comboBoxNodesStyleCol2.setEnabled(False)
    #     self.comboBoxCellsStyleType.setEnabled(False)
    #     self.comboBoxCellsStyleCol1.setEnabled(False)
    #
    #     self.comboBoxFlowlinesStyleType.clear()
    #     self.comboBoxFlowlinesStyleCol1.clear()
    #     self.comboBoxNodesStyleType.clear()
    #     self.comboBoxNodesStyleCol1.clear()
    #     self.comboBoxNodesStyleCol2.clear()
    #     self.comboBoxCellsStyleType.clear()
    #     self.comboBoxCellsStyleCol1.clear()
    #
    #     flow_variable_found = False
    #     node_variable_found = False
    #
    #     for da in self.demanded_aggregations:
    #         column_name = demanded_aggregation_as_column_name(da)
    #         if da['variable'] in AGGREGATION_VARIABLES.short_names(var_type=VT_FLOW):
    #             if not flow_variable_found:
    #                 flow_variable_found = True
    #                 item_text = 'Single column (graduated)'
    #                 item_data = 'single'
    #                 self.comboBoxFlowlinesStyleType.addItem(item_text)
    #                 self.comboBoxFlowlinesStyleType.setItemData(self.comboBoxFlowlinesStyleType.count() - 1, item_data)
    #                 self.comboBoxFlowlinesStyleType.setEnabled(True)
    #                 self.comboBoxFlowlinesStyleCol1.setEnabled(True)
    #             self.comboBoxFlowlinesStyleCol1.addItem(column_name)
    #
    #         node_var_names = AGGREGATION_VARIABLES.short_names(var_type=VT_NODE)
    #         node_var_names += AGGREGATION_VARIABLES.short_names(var_type=VT_NODE_HYBRID)
    #         if da['variable'] in node_var_names:
    #             if not node_variable_found:
    #                 node_variable_found = True
    #                 item_text = 'Single column (graduated)'
    #                 item_data = 'single'
    #                 self.comboBoxNodesStyleType.addItem(item_text)
    #                 self.comboBoxNodesStyleType.setItemData(self.comboBoxNodesStyleType.count() - 1, item_data)
    #                 self.comboBoxNodesStyleType.setEnabled(True)
    #                 self.comboBoxNodesStyleCol1.setEnabled(True)
    #                 self.comboBoxNodesStyleCol2.setEnabled(True)
    #
    #                 self.comboBoxCellsStyleType.addItem(item_text)
    #                 self.comboBoxCellsStyleType.setItemData(self.comboBoxNodesStyleType.count() - 1, item_data)
    #                 self.comboBoxCellsStyleType.setEnabled(True)
    #                 self.comboBoxCellsStyleCol1.setEnabled(True)
    #
    #             self.comboBoxNodesStyleCol1.addItem(column_name)
    #             self.comboBoxNodesStyleCol2.addItem(column_name)
    #
    #             self.comboBoxCellsStyleCol1.addItem(column_name)

    def validate(self):
        valid = True
        if not isinstance(self.gr, GridH5ResultAdmin):
            valid = False
        if not self.tableWidgetAggregations.rowCount() > 0:
            valid = False
        if self.checkBoxGenerateRasters.isChecked() and self.mQgsFileWidgetRasterFolder.filePath() == '':
            valid = False
        self.dialogButtonBoxOKCancel.button(QtWidgets.QDialogButtonBox.Ok).setEnabled(valid)


class StylingConfigDialog(QtWidgets.QDialog):
    def __init__(self, parent=None):
        super(StylingConfigDialog, self).__init__(parent)
        uic.loadUi(dialog_ui_fn, self)
        self.show()

